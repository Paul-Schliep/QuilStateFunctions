;; Esc to make it quit

(ns quil-state-functions.snake
	(:use [quil.core]
              [clojure.test]
	      [quil-state-functions.stateFunctions])
)

(defn setup []
	(background-color "white")
	(update-state :foodExists true)
	(frame-rate 10)
)

(defn update-snake-position []
	(cond 
		(= (get-value :snake-direction) "north") (update-state :snakeHeadY (- (get-value :snakeHeadY) 20))
		(= (get-value :snake-direction) "south") (update-state :snakeHeadY (+ 20 (get-value :snakeHeadY)))
		(= (get-value :snake-direction) "east") (update-state :snakeHeadX (+ 20 (get-value :snakeHeadX)))
		(= (get-value :snake-direction) "west") (update-state :snakeHeadX (- (get-value :snakeHeadX) 20))
	)
)

(defn draw-food []
	(draw-circle (get-value :foodX) (get-value :foodY) 20 "yellow")
)

(defn redraw-canvas []
	(background-color "white")
)


;; Split up into update-snake and draw-snake
(defn draw-snake []
	(loop [s (get-value :snake) x 0]
		(if (= (/ (count (get-value :snake)) 2) x) ()
		(do (draw-rect (first s) (second s) 20 20 "green") (recur (drop 2 s) (inc x))))
	)
)

(defn update-snake [coll]
	(update-snake-position)
	
	(let  [x1 (get-value :snakeHeadX)
	       y1 (get-value :snakeHeadY)
	       x2 (get-value :foodX)
	       y2 (get-value :foodY)]
	(vec (cons (get-value :snakeHeadX) (cons (get-value :snakeHeadY) (if (and (and (>= y1 (- y2 10)) (<= y1 (+ y2 10))) (and (>= x1 (- x2 10)) (<= x1 (+ x2 10))))
			coll
			(drop-last 2 coll))))))	
)

(defn controls []
	(cond 
		(= (key-input) "UP-ARROW") (update-state :snake-direction "north")
		(= (key-input) "DOWN-ARROW") (update-state :snake-direction "south")
		(= (key-input) "RIGHT-ARROW") (update-state :snake-direction "east")
		(= (key-input) "LEFT-ARROW") (update-state :snake-direction "west")
		;;(= key-code 16) (frame-rate 20)
	)
)

;; Student code
(def states
	{:snake [450 450 450 470 450 490 450 510] :snakeHeadX 450 :snakeHeadY 450 :foodX 150 :foodY 150 :snake-direction "north" :foodExists false :score 0}
)

(def updates
	{:setup-drawing setup :update-snake update-snake}	
)

(def display-order
	[draw-snake draw-food redraw-canvas]
)

;; Support code
(defn setup-sketch []
	(smooth)
	(setup-state (merge (hash-map :display-order display-order) (merge (hash-map :updates updates) states)))
	((:setup-drawing (get-value :updates)))
)

(defn display []
	(loop [s (reverse (get-value :display-order))]
		(if (empty? s) ()
		(do (println ((first s))) (recur (rest s)))))
)

;;Should call update function then display function
(defn draw-sketch []
	(update-state :snake (:update-snake (get-value :updates) (get-value :snake)))
	(display)
)


;; To be generated by macro
(defsketch snake
	:setup setup-sketch	
	:draw draw-sketch
	:key-pressed controls
	:title "Hungry, Hungry, Snake"
	:size [900 900]
)

(defn -main [& args])  
